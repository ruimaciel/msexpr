/* Generated by re2c 1.0.1 on Thu Apr 18 23:40:29 2019 */
#line 1 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c.re2c"
#include "rivest_canonical_lexer.h"

#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <errno.h>

struct token_t rivest_canonical_lexer(FILE * stream, struct input_t * input)
{
    assert(stream != NULL);
    assert(input != NULL);

    errno = 0;

    if(input->buffer == NULL)
    {
        input_fill(stream,input,1);
    }

    input->token = input->cursor;
    unsigned char *t2 = input->token;

    
#line 28 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c"
{
	char yych;
	yych = *input->cursor;
	switch (yych) {
	case 0x00:	goto yy2;
	case '(':	goto yy6;
	case ')':	goto yy8;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy10;
	default:	goto yy4;
	}
yy2:
	++input->cursor;
#line 73 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c.re2c"
	{
            return (struct token_t) {TOKEN_RIVEST_EOF, NULL} ;
        }
#line 53 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c"
yy4:
	++input->cursor;
yy5:
#line 77 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c.re2c"
	{
            return (struct token_t) {TOKEN_RIVEST_ERROR, NULL};
        }
#line 61 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c"
yy6:
	++input->cursor;
#line 34 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c.re2c"
	{
            return (struct token_t) {TOKEN_RIVEST_PARENTHESIS_OPEN, NULL};
        }
#line 68 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c"
yy8:
	++input->cursor;
#line 38 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c.re2c"
	{
            return (struct token_t) {TOKEN_RIVEST_PARENTHESIS_CLOSE, NULL};
        }
#line 75 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c"
yy10:
	yych = *(input->marker = ++input->cursor);
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case ':':	goto yy12;
	default:	goto yy5;
	}
yy11:
	yych = *++input->cursor;
yy12:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy11;
	case ':':	goto yy14;
	default:	goto yy13;
	}
yy13:
	input->cursor = input->marker;
	goto yy5;
yy14:
	++input->cursor;
	t2 = input->cursor;
#line 42 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c.re2c"
	{
            const long text_size = strtol((const char *)input->token, NULL, 10);
            if(errno != 0)
            {
                return (struct token_t) { TOKEN_RIVEST_ERROR, NULL};
            }

            struct token_string_t *s = (struct token_string_t *)malloc(sizeof(struct token_string_t));
            if(s == NULL)
            {
                return (struct token_t) { TOKEN_RIVEST_ERROR, NULL};
            }

            input->cursor = input->marker = input->token = t2;
            input_fill(stream,input,1);

            char * text = (char *)malloc(sizeof(char)*text_size);
            if(text ==NULL)
            {
                return (struct token_t) { TOKEN_RIVEST_ERROR, NULL};
            }

            text = strncpy(text, input->token, text_size);

            *s = (struct token_string_t){text_size,text};

            input->cursor = input->marker = input->token = input->token + text_size;

            return (struct token_t) { TOKEN_RIVEST_LPVERBATIM_STRING, s};
        }
#line 146 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c"
}
#line 80 "/home/rui/development/C/msexpr/src/deserializer/rivest_canonical_lexer.c.re2c"


    /* this part should not be reached */
    return (struct token_t) { TOKEN_RIVEST_ERROR, NULL};
}
